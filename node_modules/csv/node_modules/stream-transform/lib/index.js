// Generated by CoffeeScript 1.7.1
var Transformer, stream, util,
  __slice = [].slice;

stream = require('stream');

util = require('util');


/*

 * Transformer

Options include:

*   `parallel` (number)   
     The number of transformation callbacks to run in parallel, default to "100".

Available properties:

*    `transform.running`   
      The number of transformation callback being run at a given time.   
*    `transform.started`   
      The number of transformation callback which have been initiated.   
*    `transform.running`   
      The number of transformation callback which have been executed.   

Using the async mode present the advantage that more than one record may be 
emitted per transform callback.
 */

Transformer = function(options) {
  var _base;
  this.options = options != null ? options : {};
  this.options.objectMode = true;
  if ((_base = this.options).parallel == null) {
    _base.parallel = 100;
  }
  stream.Transform.call(this, this.options);
  this.transforms = [];
  this.running = 0;
  this.started = 0;
  this.finished = 0;
  return this;
};

util.inherits(Transformer, stream.Transform);

Transformer.prototype.register = function(options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = {};
  }
  this.transforms.push(cb);
  return this;
};

Transformer.prototype._transform = function(chunk, encoding, cb) {
  var err, transform, _i, _len, _ref, _results;
  this.started++;
  this.running++;
  if (this.running < this.options.parallel) {
    cb();
    cb = null;
  }
  _ref = this.transforms;
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    transform = _ref[_i];
    try {
      if (transform.length === 2) {
        _results.push(transform.call(null, chunk, (function(_this) {
          return function() {
            var chunks, err;
            err = arguments[0], chunks = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            return _this._done(err, chunks, cb);
          };
        })(this)));
      } else {
        _results.push(this._done(null, [transform.call(null, chunk)], cb));
      }
    } catch (_error) {
      err = _error;
      _results.push(this._done(err));
    }
  }
  return _results;
};

Transformer.prototype.end = function(chunk, encoding, cb) {
  this._ending = function() {
    return stream.Transform.prototype.end.call(this, chunk, encoding, cb);
  };
  if (this._ending && this.running === 0) {
    return this._ending();
  }
};

Transformer.prototype._done = function(err, chunks, cb) {
  var chunk, _i, _len;
  this.running--;
  if (err) {
    return this.emit('error', err);
  }
  this.finished++;
  for (_i = 0, _len = chunks.length; _i < _len; _i++) {
    chunk = chunks[_i];
    if (typeof chunk === 'number') {
      chunk = "" + chunk;
    }
    if (chunk != null) {
      this.push(chunk);
    }
  }
  if (cb) {
    cb();
  }
  if (this._ending && this.running === 0) {
    return this._ending();
  }
};


/*
`parse(udf, [options])`
`parse(data, udf, [options], callback)`
 */

module.exports = function(udf, options) {
  var callback, data, error, result, transform;
  if (arguments.length === 3) {
    data = arguments[0], udf = arguments[1], callback = arguments[2];
  } else if (arguments.length === 4) {
    data = arguments[0], udf = arguments[1], options = arguments[2], callback = arguments[3];
  }
  transform = new Transformer(options);
  transform.register(udf);
  if (callback) {
    result = [];
    error = false;
    process.nextTick(function() {
      var row, _i, _len;
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        row = data[_i];
        if (error) {
          break;
        }
        transform.write(row);
      }
      return transform.end();
    });
    transform.on('readable', function() {
      var r, _results;
      _results = [];
      while ((r = transform.read())) {
        _results.push(result.push(r));
      }
      return _results;
    });
    transform.on('error', function(err) {
      error = true;
      return callback(err);
    });
    transform.on('finish', function() {
      if (!error) {
        return callback(null, result);
      }
    });
  }
  return transform;
};

module.exports.Transformer = Transformer;
